---
title: Важливість виклику LHS або RHS
created: 2024-06-16 16:28
last modified: Sunday 16th June 2024 16:28:39
aliases: 
tags:
  - book/you-dont-know-js/scope-and-closures
---
# Важливість виклику LHS або RHS

Чому нам взагалі важливо розуміти, використовується LHS або ж RHS? Бо вони зовсім по різному працюють, якщо змінна на оголошена(не знайдена в scope's)

```js
function foo(a) {
	console.log( a + b );
	b = a;
}

foo( 2 );
```

Коли RHS вперше спробує отримати значення змінної `b` воно буде не знайдено. Такі змінні називаються неоголошеними(`undeclared`), бо їх не знайшли в Scope

І якщо RHS не зможе знайти значення змінної в всіх вкладених Scope результатом буде [[ReferenceError]], який буде викинутий(`throw`) Engine. Важливо розуміти, що це саме [[ReferenceError]]

На контрасті, якщо буде виконуватись пошук LHS і буде досягнутий global scope та змінна не буде знайдена, і тільки якщо програма не виконується в [[Strict mode]], тоді global scope створить **нову глобальну змінну** і поверне її до Engine

_"No, there wasn't one before, but I was helpful and created one for you."_

[[Strict mode]] був доданий в [[ES5]] та має деяку кількість відмінних поведінок від звичайного режиму. Одною з таких поведінок є заборона автоматичного створення глобальних змінних. В такому випадку глобальна змінна не буде створенна на глобальному scope та буде повернута [[ReferenceError]], як і в RHS

Тепер, якщо змінна буде знайдена через RHS, але ви будете намагатись з нею робити дивні речі, наприклад викликати як функцію не-функціональне значення, або спробувати взяти якийсь параметр у null або undefined, тоді Engine поверне трохи іншу помилку - [[TypeError]]

[[ReferenceError]] це помилка пошуку в Scope, а [[TypeError]] - коли пошук в Scope пройшов добре та все правильно, але з результатом робляться якісь нелегальні/неможливі речі