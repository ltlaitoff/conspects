---
title: Як працює традиційний компілятор
created: 2024-06-11 15:43
last modified: Tuesday 11th June 2024 15:43:34
aliases: 
tags:
  - book/you-dont-know-js/scope-and-closures
---
# Як працює традиційний компілятор

У традиційному процесі компілятор chunk коду, тобто наша програма, зазвичай проходить три кроки перед тим, як її виконати, що грубо можна назвати компіляцією

## Три кроки
### Tokenizing/Lexing

%% [[Lexing]] [[Tokenizing]] %%

Розбиває строку символів коду на значущі(для мови) чанки, які називаються **токенами**

Наприклад, строка `var a = 2;` скоріше за все буде розбита на такі токені: `var`, `a`, "="(obsidian dataview...), `2`, `;`. Пробіли та відступи також можуть бути використані, але це залежить від того, чи потрібні вони

Note: Різниця між tokenizing та lexing є тонкою та академічною, але вона зосереджена на тому, чи ідентифікуються ці токени в безстанний(без стану) або станний(зі станом) спосіб

Простими словами, якщо токенізатор викликає станні правила розбору, щоб визначити, чи слід вважати певний символ окремим токеном або частиною іншого токена, то це буде лексичний аналіз.

### Parsing

Береть масив токенів та перетворюється на дерево вкладених елементів, які колективно представляють граматичну структуру програми

Це дерево називається [[Abstract Syntax Tree|AST]] або [[Abstract Syntax Tree]]

Дерево для `var a = 2;` може починатись з верньої ноди `VariableDeclaration`, з дочірньою нодою `Identifier` (де значення буде `a`), а також іншою дочірньою нодою `AssignmentExpression` яка може включати в себе ще одну дочірню ноду `NumericLiteral` (яка може мати значення `2`)

### Кодо-генерація

Процес при якому ми беремо [[Abstract Syntax Tree|AST]] та перетворюємо його на код, який можна виконати

Цей процесс досить сильно залежить від мови програмування та середовища, для якого створюється код

Щоб не занурюватись в деталі ми скажемо, що існує способ взяти AST для `var a = 2;` та перетворити його на набір машиних інструкцій для фактично створення змінної під назвою `a`(включаючи резерування пам'яті, тощо), а потім зберегти значення в `a`

## Рушій JS

Це продовження [[Javascript - компільована мова програмування]]

Javascript-engine набагато більш складніший, ніж ці три кроки, як і більшість інших компіляторів мов програмування
Наприклад, при розборі та генерації коду є обов'язкові етапи для оптимізації продуктивності виконання коду, включаючи видалення не використовуванних значень, тощо

Хоч ми і розглядаємо ці деталі на досить високому рівні, вони все одно досить важливі для розуміння

Javascript-engine не має розкоші(як інші компілятори) мати багато часу для оптимізації, оскільки компіляція JavaScript не відбувається заздалегіть, як в інших мовах програмування

В JavaScript компіляція відбувається за **мікросекунди**(а іноді навіть швидше) перед тим, як код буде виконанно. Щоб забезпечити найкращу продуктивність JS движки використовуються всякі хитрощі, такі як [[Just In Time|JIT]] компіляцію, яка використовується за потреби та навіть компіляцію під час виконання іншого коду

==Отже, JS-компілятор спочатку візьме програму, скомпілює її, а потім буде готовий до її виконання, зазвичай відразу==