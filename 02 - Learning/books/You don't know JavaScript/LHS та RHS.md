---
title: LHS та RHS
created: 2024-06-12 23:30
last modified: Wednesday 12th June 2024 23:30:02
aliases: 
tags:
  - book/you-dont-know-js/scope-and-closures
---
# LHS та RHS

Коли `Engine` виконує код який йому надав `Compiler` він повинен подивитись/пошукати/`look-up` чи змінна `a` вже оголошена, і цей пошук звертається до `Scope`. Але тип `look-up`, який виконує `Engine`, має вплив на результат

У нашому випадку ми будемо говорити, що `Engine` виконує `LHS` пошук для змінної `a`. Інший тип пошуку називається `RSH`.

I bet you can guess what the "L" and "R" mean. These terms stand for "Left-hand Side" and
"Right-hand Side".

Можна вгадати, що таке `L` та `R`. Це терміни для `Left-hand Side` та `Right-hand size` (по ліву сторону, по праву сторону)

Сторону... чого? **Операції присвоєння**

Іншими словами, `LHS` пошук виконується коли коли змінна з'являється по ліву сторону від операції присвоєння, а `RHS` - по праву

Але, давайте будемо трохи точніші. Для наших цілей `RHS` пошук не відрізняється від пошуку значення змінної, тоді як `LHS` пошук намагається знайти сам контейнер змінної, щоб можна було присвоїти їй значення

Таким чином, `RHS` насправді означає не `right-hand side of a assignment`, а скоріше `not left-hand side of a assignment`

Також можна думати про `RHS` як про отримання значення

Коли ми говоримо \

```js
console.log( a )
```

Посилання на змінну `a` це `RHS`, бо нічого не присвоюється `a`, навпаки ми шукаємо значення щоб потім передати його в `console.log`

На контрасті:
```js
a = 2;
```

Це посилання - `LHS`. Бо, насправді, нам не важливо яке там значення зараз, ми хочемо просто отримати змінну, щоб потім записати в неї значення `2`

`LHS` та `RHS` не обов'язково означаються ліву або праву сторону саме оператора присвоєння =. Є ще декілька шляхів коли присвоєння відбувається, тому краще думати про них як `хто ціль для присвоєння(LHS)` та `хто значення для присвоєння(RHS)`

Розглянемо програму, яка має посилання як на `LHS`, так і на `RHS`
\
```js
function foo(a) {
	console.log( a )
}

foo( a )
```

Останній рядок який викликає `foo` як функцію вимагає RHS посилання на `foo`, що означає "йди подивись(`look-up`) значення foo та дай його мені". Тим більше `(..)` означає, що цю змінну можна викликати, тому це має бути функція!

Також тут є тонке, але дуже важливе присвоєння, яке досить просто можна пропустити

Це присвоєння `a = 2`. Воно відбувається коли значення `2` передається як аргумент фукнції до `foo(..)`. В цьому випадку параметру `a` присвоюється значення `2`. Для (неявного) присвоєння використовується пошук `LHS`

Також є посилання на `RHS` щоб взяти значення `a` та значення передати до `console.log(..)`. `console.log(..)` також потребує `RHS` посилання для визначення `console` об'єкта, потім відбується розв'язання залежностей, щоб перевірити, чи існує метод `log`.

Нарешті ми можемо уявити, що відбувається обмін `LHS` та `RHS` при передачіь значення 2(шляхом звернення до `RHS` змінної `a`) в `log(..)`.

У внутрішній реалізації `log(..)` ми можемо припустити, що функція має параметри, перший з яких (можливо, називається `arg1`) має звернення до `LHS` перед тим, як присвоїти йому значення `2`.

Note: Може виникнути спокуса подумати, що оголошення функції `function foo(a) {...}` виконується так само, як `var foo` та `foo = function(a)`. Таким чином, можна подумати, що оголошення цієї функції викликає `LHS`

Однак тонка, але важлива різниця полягає в тому, що компілятор обробляє як і оголошення(`declaration`), так і визначення значень(`value definition`) від час кодо-генерації, таким чином під час виконання код `Engine` немає необхідності "присвоювати" значення функції `foo`. Тому не зовсім корректно думати про оголошення функції як про присвоєння зі зверненням до LHS у тому вигляді, в якому ми їх тут обговорюємо

