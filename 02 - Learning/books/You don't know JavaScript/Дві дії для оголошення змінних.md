---
title: Дві дії для оголошення змінних
created: 2024-06-12 23:23
last modified: Wednesday 12th June 2024 23:23:00
aliases: 
tags:
  - book/you-dont-know-js/scope-and-closures
---
# Дві дії для оголошення змінних

Ми будемо вивчати як працює Scope, розглядаючи цей процес в вигляді розмови. Але хто веде цю розмову?

## Актери, або ж основні діякі

Акторами які будуть взаємодіяти, щоб виконати програми `var a = 2;` будуть:
- `Engine` - Відповідає за компіляція та виконання нашого JavaScript від початку до кінця
- `Compiler` - Один з друзів `Engine`. Виконує всю брудну роботу по парсингу, створенню [[Abstract Syntax Tree|AST]], а також кодо-генерації
- `Scope` - Ще один друг `Engine`. Збирає та підтримує список для пошуку всіх оголошенних змінних і застосовує суворий список правил  щодо того, як вони доступні для поточного коду, що виконується

Щоб повністю зрозуміти, як працює JavaScript нам потрібно думати як думають `Engine` та його друзі, задавати запитання які задають вони та відповідати на них також

## Дві дії для змінних

Коли ми бачимо `var a = 2;` ми думаємо про це, як про одне `statement`(заява, об'явлення, твердження, тощо)

Але наш друг `Engine` бачить це інакше. Насправді `Engine` бачить два різних `statement`, одне, яке `Compiler` оброблює під час компіляції, і інше яке `Engine` оброблює під час виконання

Тож, як `Engine` та друзі будуть виконувати програму `var a = 2;`

Перше, що зробить `Compiler` це розіб'є строку на токени та створить [[Abstract Syntax Tree|AST]]. Але коли `Compiler` дійде до генерації коду він буде це дещо інакше, ніж, можливо, припускалось

Розумним припущенням є те, що компілятор створить код, приблизно такий(на псевдокоді): "Виділи пам'ять для змінної, позначьте її `a`, задайте їх значення `2`". Але це не зовсім точно

Замість цього `Compiler` буде діяти так:
1. Коли `Compiler` зустрічає змінну `a` він запитує у `Scope` чи вже існує ця змінна в цій області видимості. Якщо існує - він пропускає це оголошення і йде далі. Якщо не існує - просить `Scope` оголосити нову змінну `a` для цієї області видимості
2. Потім `Compiler` передає код до `Engine` для майбутнього виконання, присвоєння `a = 2`. `Engine` спочатку запитує у `Scope` чи існує така змінна. Якщо так, що використовує її. Якщо ні - дивиться [[Вкладений Scope]]

Якщо `Engine` знаходить змінну - він задає їй значення `2`. Якщо ні - видає помилку

Тобто, для оголошення змінної виконується дві різні дії: По перше `Compiler` оголошує змінну, якщо вона вже не була оголошенна в поточній області видимості. А по друге `Engine` шукає змінну в області видимості та присвоює їй значення якщо вона знайденна

