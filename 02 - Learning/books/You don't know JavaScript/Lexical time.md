---
title: Lex-time
created: 2024-06-19 14:24
last modified: Wednesday 19th June 2024 14:24:30
aliases:
tags:
  - book/you-dont-know-js/scope-and-closures

---
# Lexical time

Як ми пам'ятаємо з [[Як працює традиційний компілятор]] у стандартних компіляторів є перша фаза яка називається `Lexing`. Фаза в якій велика строка коду розбивається на токени, а також призначається значення у результаті деякого аналізу стану

Саме ця концепція є основою того, звідки походить назва [[Lexical scope]] та що це таке

`Lexical scope` визначається під час `lexing time`. Іншими словами, `lexical scope` базується на тому які змінні та блоки scope створені ВАМИ під час написання коду, і таким чином(переважно), фіксується на момент, коли лексичний аналізатор оброблює ваш код

**Note:** Ми побачимо декільках шляхів як можна змінювати lexical scope після `lexing time`, але їх краще не використовувати

Чудовою практикою вважається розуміти `lexical scope`, по факту, як тільки лексичний, тобто повністью авторський за своєю природою

Розглянемо блок коду:

```js
function foo(a) {

	var b = a * 2;

	function bar(c) {
		console.log( a, b, c );
	}

	bar(b * 3);
}

foo( 2 ); // 2 4 12
```

Тут є 3 вкладені scope одний в інший. Можливо буде краще розглядати ці області їх як `бульбашки` одна всередині іншої 

![[Pasted image 20240619143422.png]]

**Бульбашка 1** представляє собою `global scope` та має тільки один ідентифікатор: `foo`

**Бульлашка 2** представляє `scope` `foo`, який має 3 ідентифікатори: `a`, `bar` та `b`

**Бульбашка 3** представляє собою `scope` `bar` який включає тільки один ідентифікатор `c`

Бульбашки `scope` визначаються тим, як блоки `scope` були написані, який вкладений в інший і тд. В наступний главі будуть розглянуті різні юніти `scope`, але зараз давайте думати, що кожна функція створює нову бульбашку `scope`

Бульбашка `bar` повністью включається в бульбашку `foo` томі і тільки тому, що ми вирішити там оголосити функцію `bar`

Зверніть увагу, що вкладені бульбашки строго вкладені. Бульбашки не можуть мати перетинів з іншими бульбашками, як це наприклад зображено на діаграмах Вієна

Іншими словами, бульбашка деякої функції НЕ може існувати(частково) в двох зовнішніх бульбашках так само, як і функція не може бути частково оголошена всередині двох батьківських функцій 