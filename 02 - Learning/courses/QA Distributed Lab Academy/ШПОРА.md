**Тестування програмного забезпечення** - це процес перевірки відповідності заявлених до продукту вимог та дійсно реалізованої функціональності, що здійснюється шляхом спостереження за його роботою у штучно створених ситуаціях та на обмеженому наборі тестів

Але на практиці для тестування використовується все що можна для отримання уявлення про ці вимоги до чогось. Наприклад:
- Життєвий досвід
- Здоровий глузд
- Спілкування з розробниками, лідами і тд
- Установлені стандарти
- Google

Робота тестувальника включає планування, складання тестів, безпосередньо виконання тестування та аналіз отриманих даних

Головне завдання тестування - пошук багів

- Надання інформації, у поточний час розробки, про якість ПЗ кінцевому замовнику
- Підвищення якості ПЗ
- Запобігання появі багів.

- При початку розробки ПЗ тестери намагаються по максимуму зламати програму щоб виявити всі недоліки
- При здачі проекту задача тестерів щоб проект працював правильно
- При супровіду проекту при тестуванні необхідно переконатись, що не з'явилось ніяких нових багів

**Чим раніше ми знайдемо баг, тим дешевше буде коштувати його виправити**

В крайніх випадках якщо баг знаходиться на дуже пізніх етапах розробки його можуть залишити, бо він його фікс коштує більше, ніж коштує цей баг

**Сім основних принципів тестування:**
- Помилка про відсутність помилок
- Тестування залежить від контексту
- Тестування демонструє(тільки) наявність багів
- Парадокс пестициду
- Тестування має розпочинатися якомога раніше (заощаджує час та гроші)
- Вичерпне тестування неможливе
- Принцип накопичення багів (Принцип Парето 80/20) або кластерізація багів

Є два види контексту: ???
- Зовнішній - які в проекті домені області, кінцеві користувачі
- Внутрішний - мої розробники або кількість розробників на проекті змінюється або різне навантаження

QA - забезпечує правильність та передбачуваність процесу
QC - передбачає контроль за дотриманням вимог, які ставить QA
Tester - забезпечує збирання статистичних даних та внесення їх до документів 


SDLC:
1. Збір вимог
2. Проєктування
3. Розробка & програмування
4. Тестування
5. Впровадження та підтримка

SDLC - Sorftware testing lifecycle

- Аналіз вимог<mark style="background: #FFB8EBA6;"> - </mark>Коли список вимог готовий та представлений зацікавленим сторонам, група тестування розпочинає аналіз високого рівня щодо аналізу вимог.
- Планування тестування<mark style="background: #FFB8EBA6;"> - </mark>Команда планує стратегію та підхід.
- Проєктування тест-кейсів<mark style="background: #FFB8EBA6;"> - </mark>Розробка тест-кейсів на основі обсягу та критеріїв.
- Виконання тесту<mark style="background: #FFB8EBA6;"> - </mark>Перевірка продукту в режимі реального часу та пошук помилок.
- Закриття тесту<mark style="background: #FFB8EBA6;"> - </mark>Після тестування: звіти, результати документуються.

Waterfall (з англ. - "Водоспад") - передбачає послідовний перехід до кожного етапу розробки і неможливість повернутися на крок назад. Внести будь-які зміни буде можливо лише після релізу проєкту

![[Pasted image 20230722174123.png]]

Agile - система, заснована на принципі "гнучкого" управління проєктами. Сюди відносять методики Scrum, Kanban, Екстремальне програмування (XP), Lean тощо.


**Scrum** – система гнучкої розробки проєктів, що базується на принципі спринту. Від 1 тижня до місяця має бути готова робоча версія продукту. Це **ітераційно-інкрементальна** модель розробки. В кінці **ітерації** - видається робочий **інкремент**


| Показник  |  Scrum | Kanban  |
|---|---|---|
|Тривалість циклу|Регулярні спринти фіксованої тривалості (наприклад, 2 тижні).|Неперервний процес.|
|Підходи до релізів|Наприкінці кожного спринту після схвалення Product owner’a.|Постачання виконується безперервно або на розсуд команди.|
|Ролі|Власник продукту, Scrum-майстер, команда розробників.|Ролі, як такі відсутні. Іноді зустрічаються Agile-тренери.|
|Ключові показники|Швидкість команди.|Зміни можуть відбутися у будь-який момент.|


![[Pasted image 20230722174418.png]]



`Test Design` – це етап процесу тестування ПЗ, на якому проєктуються та створюються тестові випадки (`Test case`), відповідно до визначених раніше критеріїв якості та цілей тестування.

Цілі тест-дизайну:
- Забезпечити покриття функціональності тестами;
- Тести повинні покривати всю функціональність;
- Тестів має бути мінімально достатньо;

Задачі тест-дизайну
1. Проаналізувати вимоги до продукту;
2. Оцінити можливі ризики під час використання продукту;
3. Написати достатню мінімальну кількість тестів;
4. Розмежувати тести на Приймальне, Критичне, Розширене;

Навички для крутого тест-дизайну:
1. Декомпозиція програми — розбивання системи, що тестується, на компоненти;
2. Навички та можливості пошуку додаткової інформації для програми;
3. Розставлення пріоритетів;
4. Грамотна мова та вірний вектор розумового процесу;
5. Знання техніки тест-дизайну;
6. Відточена майстерність застосування технік тест-дизайну;

Ролі, відповідальні за тест-дизайн:
- Тест-аналітик – визначає "**ЩО тестувати?**"
- Тест-дизайнер –  визначає "**ЯК тестувати?**"

Задачі тест аналітика:
- дослідити продукт; 
- скласти логічну карту товару;
- розбити програмний продукт на складові;
- розставити пріоритети тестування

1. Бізнес-Аналітик та Тест-Аналітик (QA) виконує аналіз продукту, розбиває його на складові, розставляє пріоритети тестування та складає логічну карту програми;
2. Тест-дизайнер(QC) на підставі інформації, отриманої від аналітика, розпочинає розробку тестів;
3. Тестувальник проводить безпосередньо тестування за вже готовими тест-кейсами.

6 основних технік тест-дизайну:
1. Еквівалентне розбиття
2. Граничні значення
3. Таблиця прийняття рішень
4. Попарне тестування
5. Причина і наслідок
6. Передбачення помилок

Тестовий випадок (**Test Case**) - це артефакт, що описує сукупність кроків, конкретних умов і параметрів, необхідних для перевірки реалізації функції або її частини, що тестується.

**Високорівневий тест-кейс** – тест-кейс без конкретних вхідних даних та очікуваних результатів. Як правило, обмежується загальними ідеями та операціями, схожим за своєю суттю з докладно описаним пунктом чеклиста. Досить часто зустрічається в інтеграційному тестуванні та системному тестуванні, а також на рівні димового тестування. Може бути відправною точкою для проведення дослідницького тестування або для створення низькорівневих тест-кейсів.

**Низькорівневий тест-кейс** - тест-кейс із конкретними вхідними даними та очікуваними результатами. Є повністю готовим до виконання тест-кейс і є найбільш класичним видом тест-кейсів. Тестувальників-початківців найчастіше вчать писати саме такі тести, оскільки прописати всі дані докладно набагато простіше, ніж зрозуміти, якої інформації можна знехтувати, при цьому не знизивши цінність тест-кейсу.

Структура тест-кейсу 
- Ідентифікатор
- Пріоритет
- Вимога
- Модуль
- Назва тест-кейсу
- Кроки тест-кейсу
- Очікувані результати

Існують 6 правил ведення тест-кейсів:
1. Один тест-кейс має перевіряти лише одну конкретну функціональність.
2. Тест-кейс не повинен залежати від інших тест-кейсів. 
3. Кроки та очікуваний результат тест-кейса мають бути сформульовані чітко та однозначно.
4. У тест-кейсі має бути вся інформація, потрібна для його проведення.
5. У тесті кейсі не повинно бути лишніх деталей.
6. Для кожного кроку тест-кейса потрібно вказувати тип введених даних: валідний або не валідний.
 
У тест-кейса може бути 3 види результатів:
1. Позитивний результат тест-кейса. Фактичний результат тесту кейса збігається з очікуваним.
2. Негативний результат тест-кейса. Фактичний результат тесту кейса відрізняється від очікуваного.
3. Тест-кейс не завершено. Під час перевірки тест-кейса відбувається помилка.

**Баг** – це **невідповідність фактичного результату виконання програми до очікуваного результату**. 

**Баг-репорт (bug-report) –** це технічний документ, що містить у собі повний опис багу, куди входить інформація, як про сам баг (короткий опис, серйозність, пріоритет тощо) так і умови виникнення даного багу. Баг-репорт повинен містити правильну, єдину термінологію, що описує елементи інтерфейсу користувача і події даних елементів, що призводять до виникнення багу.

**Мінімально необхідні атрибути баг-репорту:**

* Короткий опис **(Summary).** Поле, в якому потрібно помістити весь зміст всього баг-репорту. Найчастіше, у короткому описі лаконічно відповідають на 3  головні питання: «Де?», «Що?», «Коли?» (саме в такій послідовності, як би не хотілося змінити її за прикладом відомої гри).
* Серйозність **(Severity)**. Атрибут, який вказує вплив багу на нашу систему.
* Кроки відтворення **(Steps To Reproduce).** Точний і зрозумілий опис **всіх кроків**, що призводять до появи багу, з урахуванням усіх необхідних вхідних даних тощо.
* Очікуваний результат (**Expected result**).
* Фактичний результат (**Actual result**).

**Інколи, мінімально необхідних атрибутів може не вистачати, то користуються ще такими атрибутам**

**В назві**
* Компонент програми **(Component).** У якому компоненті або модулі виник баг
* Версія **(Version)**. Версія білду, у якому знайдено баг.
* Пріоритет **(Priority)**. Швидкість виправлення багу.
* Статус **(Status)**. Відображає статус багу у своєму життєвому циклі.
* Автор **(Reporter)**. Автор баг-репорту.
* Призначення **(Assignment)**. Хто має виправити баг.

**Оточення** **(Environment)**
* Операційна система, розрядність, браузер, його версія тощо.

**Опис** 
* Детальний опис **(Description)**
* Перед умови **(Preconditions)**

**Доповнення** **(Attachments)**
* Прикріплений файл (логи, скриншот, інші документи, які можуть допомогти відтворити проблему або вирішити її)

**Серйозність** - це атрибут, що вказує вплив багу на систему. Наскільки постраждає наша система, якщо юзер зіштовхнеться з цим багом.

Серйозність:

* <mark style="background: #FF5582A6;">Blocker</mark>. Блокувальний баг. Вона унеможливлює всю подальшу роботу з програмою. Для відновлення роботи необхідно виправити Blocker.
* <mark style="background: #FFB86CA6;">Critical</mark>. Критичний баг. Порушує роботу основної функціональності. Баг проявляється постійно та унеможливлює використання основних функцій програми.
* <mark style="background: #FFF3A3A6;">Major</mark>. Значний баг. Ускладнює роботу основної функціональності або унеможливлює використання додаткових функцій.
* <mark style="background: #ADCCFFA6;">Minor</mark>. Незначний баг. На функціональність системи впливає мало, ускладнює використання додаткових функцій. Для обходу цього багу можуть бути очевидні шляхи.
* <mark style="background: #BBFABBA6;">Trivial</mark>. Тривіальний баг. Не впливає на функціонал проєкту, але погіршує загальне враження від роботи з продуктом.

Пріоритет:

* <mark style="background: #FF5582A6;">High</mark>. Високий пріоритет. Призначається багам, які мають бути усунені насамперед.
* <mark style="background: #FFB86CA6;">Normal</mark>. Звичайний пріоритет призначається за замовчуванням. Ці баги усуваються у другу чергу, у штатному порядку.
* <mark style="background: #FFF3A3A6;">Low</mark>. Низький пріоритет. Призначається багам, які не впливають на функціонал. Виправлення таких багів відбувається в останню чергу, якщо є час та ресурси.

## Класифікація видів тестування
### За знанням системи

За знанням системи є **три види** тестування: Тестування **чорної, білої та сірої скриньок**

**Тестування чорної скриньки (black box)** - При цьому виді тестування знання коду програми, внутрішньої структури та знань програмування загалом не потрібні. Тут ми тестуємо, як **звичайний юзер**, котрий вперше побачив цю систему.

**Тестування сірої скриньки (grey box)** - знаємо внутрішню логіку коду, але тестуємо, як звичайний юзер.  

**Тестування білої скриньки (white box)** - Повний антипод чорної скрині. Тут ми вже тестуємо з повним розумінням внутрішньої логіки, а також доступом до коду, та змогою його редагувати.

### **За суб'єктом тестування**

Все дуже просто. Субʼєкт - це той, хто проводить тестування. 

Всього може бути два субʼєкти: 

* Альфа тестувальник (**alpha tester**);
* Бета тестувальник (**beta tester**).

Альфа тестувальник (**alpha tester**) - Це співробітники компанії, які професійно чи непрофесійно проводять тестування: тестувальники, розробники, бухгалтери, сисадміни, девопси. У стартапах напередодні релізу нерідко всі працівники, сидять по 16 годин поспіль, намагаючись знайти не відловлені баги.

Бета тестувальник (**beta tester**) - Не співробітник компанії, котрому пощастило першим побачити нову версію ПЗ. Це можуть бути як і найняті юзери для закритого тестування, так і просто частина вже наявних юзерів (зазвичай 1-10%) 

### За позитивністю сценаріїв

- Позитивне тестування (**positive testing**). Перевірка позитивних сценаріїв користувача. На вхід подаються очікувані дані.

- Негативне тестування (**negative testing**). Перевіряє реакцію системи на введення негативних (не дозволених/некоректних) даних.

### **За ступенем автоматизації**

Тому перед тим як буде перевірена нова функціональність потрібно перевірити чи працює вся інша. 

Є три види. **Ручне**, **Автоматизоване** і **Напівавтоматизоване тестування**. 

### За часом проведення тестування

1. Альфа-тестування. Імітація реальної роботи внутрішньою командою. Також під час тестування використовують тестування повʼязане зі змінами, а саме: 
    1. Димове тестування (**smoke testing**)
    2. Ре-тест **(Re-test)**
    3. Санітарне тестування (**sanity testing**) 
    4. Регресійне тестування (**regression testing**)
2. Приймальне тестування (**acceptance testing**)
3. Бета-тестування

Якщо розглядати за таймлайном, то ми спочатку робимо Альфа-тестування під час розробки, потім Приймальне тестування за завершенням розробки та потім Бета-тестування за межами команди.   

Тестування  повʼязані зі змінами хоч і згадуються в тестуванні за часом, але це є окремий вид тестування. Тому більш детально про тестування повʼязані зі змінами, нижче буде розписано окремим пунктом.    

### Тестування за змінами

Тому перед тим як буде перевірена нова функціональність потрібно перевірити чи працює вся інша. 



|                | Димове (Smoke)                                                                                 | Ре-тест (Re-test)                                     | Саніті (Sanity)                                                                                     | Регресійне (Regression)                                                                                                                                              |
| -------------- | ---------------------------------------------------------------------------------------------- | ----------------------------------------------------- | --------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Мета           | Виконуються з метою швидкої перевірки критично важливої функціональності                       | Мета - перевірити є чи були виправлені дефекти        | Метою є перевірити загальний стан системи в деталях, щоб приступити до більш ретельного тестування. | Мета — переконатися, що свіжі зміни в коді не надали побічних ефектів на функціональність, що була розроблена і протестована раніше.                                 |
| Пріоритет      | Пріоритет виконання найвищий                                                                   | Ре-тест виконується перед sanity-тестуванням.         | Виконується перед регресивним тестуванням                                                           | Проводиться на підставі вимог проєкт та доступності ресурсів (закривається автотестами), «регрес» може проводитись у паралелі з ре-тестами                           |
| Автоматизація | Може виконуватись автоматизовано або вручну                                                    | Не піддається автоматизації                           | Найчастіше виконується вручну                                                                       | Найкращий привід для автоматизації цього виду тестування тому, що  ручне може бути вкрай витратним за ресурсами чи часом                                             |
| Документація   | Тест-кейси є частиною регресійних тест-кейсів, але покривають вкрай критичну функціональність. | Використовується той же тест-кейс, який виявив дефект | Санітарне може виконуватися без тест-кейсів, але знання системи, що тестується, обов'язково         | Тест-кейси регресійного тестування можуть бути отримані з функціональних вимог або специфікацій, мануалів, і проводяться незалежно від того, що виправили розробники |


### **За рівнями тестування**

![](https://lh5.googleusercontent.com/FKwEQByTUaLo3q40rni7ZYEVTFmM6MB1aZlUdiHVSQeQyBmX3dPEyQOwI4_lIYyxgJTifQQEpTzH1b9gmOXXzO5hcaU0FLp0XFK9hRc0zlwqRllGS_KqVhZPZUTxuhZF4Oecp_sip5SYYED2Box4rgM)

#### ​​Модульне тестування (Unit testing) 

#### Інтеграційне тестування (Integration testing) 

#### Системне тестування (**System testing**)

Тестується інтегрована система її відповідність вимогам. Направлено на перевірку всієї програми, як єдиного цілого, зібраного з частин, перевірених на модульному та інтеграційному рівнях.

#### Приймальне тестування (**Acceptance Testing**)

Це формальний процес тестування, який перевіряє відповідність системи вимогам і проводиться з метою визначення, чи задовольняє система приймальним критеріям та винесення рішення замовником або іншою уповноваженою особою приймається додаток чи ні.

### За об'єктом тестування

#### Функціональне і нефункціональне тестування. Як відрізняти ?

Перед тим як розмовляти більш детально, найбільша різниця між ними це те що 

**функціональне тестування** полягає у тестуванні функціональностей наявних у додатку та переконання у тому, що вони працюють згідно зі специфікаціями. 

**Нефункціональне тестування** стосується аспектів програмного забезпечення, які не пов’язані з конкретними функціями чи операціями. 

Це оцінює роботу системи з точки зору відповідності набору вимог, таких як продуктивність, безпека, сумісність та стабільність.

1. Функціональне тестування (**functional testing**). Перевірка функцій та характеристик ПЗ, що розробляється на основі проєктної документації;
2. Тестування продуктивності (**performance testing**). Перевіряє працездатність системи під навантаженням. Може служити для перевірки та підтвердження інших атрибутів якості системи, таких як масштабованість, надійність та споживання ресурсів. Виділяються такі підвиди:
	* Навантажувальне тестування (**load testing**). Тестування часу відповіді програми на запити різних типів, з метою переконатися, що додаток працює відповідно до вимог при звичайному користувацькому навантаженні.
	* Стрес-тестування (**stress testing**). При стрес-тестуванні (найчастіше, тільки при ньому) ми можемо отримати реальні дані границь продуктивності додатка, досліджувати здатність програми обробляти виключення, її стабільність та стійкість. Саме в значно збільшених навантаженнях на додаток і полягає різниця між тестуванням продуктивності та стрес тестуванням.
	* Тестування стабільності (**stability testing**). Досліджує працездатність додатка при тривалій роботі у часі за нормального навантаження програми.
3. Юзабіліті-тестування (**usability testing**). Мета даного виду тестування полягає у визначенні ступеня зручності та практичності користувальницького інтерфейсу;
4. Тестування графічного інтерфейсу користувача (**GUI**) — це метод тестування, в якому перевіряється відповідність графічного інтерфейсу користувача заданим стандартам та вимогам які становив замовник.
5. Тестування безпеки (**Security Testing**). Перевірка надійності системи від можливих ризиків та загроз (втрата, конфіденційність, цілісність та доступність даних). Варто зазначити що таке тестування проводиться спеціалістами цієї сфери;
6. Тестування локалізації (**localization testing**). Коректність роботи окремих компонентів системи (формати дат, одиниці виміру, не змінюється часовий пояс під час переїзду тощо);
7. Тестування інтернаціоналізації (**internationalization**). Дозволяє переконатися у підтримці культурних особливостей інших країн 
8. Тестування сумісності (**compatibility testing**). Перевірка можливості програми взаємодіяти з різними програмними продуктами, операційними системами та оточенням.