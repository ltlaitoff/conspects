---
Tags:
 - git
---
# Ответы на вопросы с собеседований git

## В чём разница между fork, branch и clone?
`fork` - удалёная копия удалёного репозитория. После создания fork'а пользователь может вносить изменения в скопированную версию, а в дальнейшем присоединить свои изменения к оригинальному.
`clone` – создание локальной копии удаленного репозитория. При клонировании копируются все данные
`branch` – создание и управление ветками


## В чем разница между pull request и branch?
`branch` – это ветка, которую в последствии можно `merge` с `main` по средствам либо прямого написания команды `git merge`, либо через `pull request` на удалённом сервере.

`pull request` – этот запрос на внесение изменений в репозиторий. После создания `pull request` запрос может быть просмотрен(`review`), а после либо принят, либо нет.


## Объясните разницу команд git pull и git fetch?
`fetch` - Получение изменений с удалённого сервера. После получения пользователь должен вручную сделать `merge` либо `rebase`.
`pull` - Получение изменения с удалёного сервера(`git fetch`) и слияние либо перебазирование(`merge`/`rebase`), в зависимости от настроек, изменений с локальной копией репозитория.


## Как отменить предыдущий `commit`?
Отменить `commit` можно двумя разными командами: `reset` и `revert`

### Reset
`git reset` позволяет отменить предыдущий `commit` удалив его, как будто его и не было.

`Reset` хорошо работает в локальных репозиториях, но при взаимодействии с удалённым непременно возникнут проблемы с `merge` изменений.

A - B - C(F)

##### Полное удаление `commit`'а:
```zsh
git reset --hard HEAD~1
```
Полностью удаляет предыдущий `commit` без возможности его востановления. Использовать эту команду нужно только если вы действительно уверены что хотите удалить `commit` безвозвратно

##### Отменить `commit`, но сохранить сделанные изменения
```zsh
git reset HEAD~1
```
Мы передвигает HEAD на 1 `commit` назад, но при єтом оставляем файлы в том же состоянии, в котором они находятся. `git status` покажет что файлы соответствуют фиксации C

##### Отменить `commit`, но сохранить все проиндексированные файлы
```zsh
git reset --soft HEAD~1
```
Удаляет `commit`, но сохраняет индексацию файлов

### Revert
Второй способ отменить `commit` - сделать ещё один `commit` полностью противоположный тому, который нужно отменить. 

Данный способ не ломает историю `commits` и используется всегда, если `commit` уже попал в удалённый репозиторий.

```zsh
git revert <commit-hash>
```


## Что такое git cherry-pick?
`git cherry-pick` - команда `git`, которая используется для перенесения отдельных `commit` из одного места в репозитория в другое. Обычно используется между ветками разработки и обслуживания. 
```zsh
git cherry-pick <commit-hash>
```


## Расскажите о преимуществах forking workflow
Основными приемуществами `forking workflow` является:
- Чистая история `commit` главного репозитория из-за фильтрации `pull requests`
- Удобство для каждого `конрибьютера`, а именно возможность сделать измения и создать `pull request` без необходимости получать доступ к созданию изменений(пользователю не нужно входить в список мейнтейнеров проекта что-бы иметь возможность сделать pull request и предлагать свои изменения)


## В чем разница между HEAD, рабочим деревом и индексом?
`Working tree` (Рабочее дерево) - Снимок одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге `git` и помещаются на диск, для того чтобы их можно было использовать или редактировать

`Staging area` (Область индексирования) — это файл, обычно находящийся в каталоге `git`, в нём содержится информация о том, что попадёт в следующий `commit`. Её техническое название на языке Git — «индекс».

`HEAD` - это ссылка на последний `commit` в текущей извлеченной ветке


## Расскажите о gitflow-организации рабочего процесса.
`Gitflow` использует две паралельные "долгие" ветки для хранения истории проекта(**main**, **develop**), а также много временных веток(**feature**, **hotfix**, **release**).

Когда разработчику нужно сделать какую-то новую *фичу* - он создаёт новую ветку относительно `develop`, разрабатывает *фичу* и создаёт `pull request` на `merge` с веткой `develop`

Когда изменений достаточно для полноценого релиза, создаётся ветка `release-<version>` в которую делается `pull request` с `develop`. После всех проверок эта ветка будет создан `pull request`, но уже на слияние с `main` веткой.

Такой подход обеспечивает максимальную безопасность, а так-же возможность быстро вернуться к нужной версии продукта

## Когда следует использовать git stash?
`git stash` позволяет добавить изменения в стек, а после через неопределённое количество времени их оттуда вытащить

В основном `git stash` используется когда нужно что-то сделать в других ветках.


## Как удалить файл из git, но оставить его в файловой системе компьютера?
`git reset <path>` позволит удалить файл из git, но при этом оставить его локально


## Когда следует использовать git rebase вместо git merge?
Если ветка, в которую вы хотите внести изменения доступна для других разработчиков - **не используйте `rebase`**. Эта команда удаляет ветку целиком и приводит к рассинхронизации копии репозиториев.

Если вы захотите отменить слияние - используйте `merge`, так как его легче/возможно отменить, по сравнению с `rebase`.

Во всех остальных случаях всё зависит от того, как вы хотите видеть историю `commits`