---
title: Класифікація видів тестування
created: 2023-08-14 13:40
Aliases:
Tags: 
 - testing
 - QA-DL-Academy
 - QA-Lecture-5_Класифікація-видів-тестування
---

# Класифікація видів тестування

## **За знанням системи**

За знанням системи є **три види** тестування: Тестування **чорної, білої та сірої скриньок**

### Тестування чорної скриньки (black box)

**Тестування чорної скриньки (black box)** - При цьому виді тестування знання коду програми, внутрішньої структури та знань програмування загалом не потрібні. Тут ми тестуємо, як **звичайний юзер**, котрий вперше побачив цю систему.

**<mark style="background: #FFB8EBA6;">Наприклад</mark>:** Всі ми трохи тестуємо методом чорної скриньки, коли використовуємо мікрохвильову піч. Ми не знаємо, як вона влаштована. Чи мікро хвилюється вона сама, чи мікро хвилює їжу, але знаємо точно, що поміж мікро хвилювань, ми ще отримуємо нагрівання їжі. 

Тестувальник знає, _що саме_ має робити програмне забезпечення, але не знає, _як саме_ вона це робить.

### Тестування сірої скриньки (grey box)

**Тестування сірої скриньки (grey box)** - знаємо внутрішню логіку коду, але тестуємо, як звичайний юзер.  

Найулюбленіший вид тестування, про котрий запитують на співбесідах.  Це і не дивно, бо він немає чітких критеріїв, але в той самий час найпопулярніший вид тестування серед тестувальників (Бо дуже важливо бути частиною проєкту і зовсім нічого не знати про внутрішню логіку ПЗ). 

З плюсів. Знаючи внутрішню логіку, ми можемо дедалі точніше передбачити баги в ПЗ. А також, правильно визначити пріоритети проходження перевірок. 

**<mark style="background: #FFB8EBA6;">Наприклад</mark>**: Та сама мікрохвильовка, але ми вже не повністю новий юзер. По перше, з власного досвіду, ми знаємо, що в неї не слід пхати сталеві предмети, тому такі стрес перевірки робимо низько пріоритетними. По друге, у нас вже є інструкція до неї. Тобто, ми так само не знаємо нічого про магнетрон, анодну лампу і різні катоди, але ми вже розуміємо, як воно працює, а як працювати точно не буде) 

### Тестування білої скриньки (white box)

**Тестування білої скриньки (white box)** - Повний антипод чорної скрині. Тут ми вже тестуємо з повним розумінням внутрішньої логіки, а також доступом до коду, та змогою його редагувати.

Цей вид тестування є, але саме тестувальники зазвичай до нього не причетні. 

<mark style="background: #FFB8EBA6;">Наприклад</mark>: Юніт тести, що допомагають розробникам самим перевірити, чи правильно вони написали код, та одразу виправити його у разі помилки.

## **За суб'єктом тестування**

Все дуже просто. Субʼєкт - це той, хто проводить тестування. 

Всього може бути два субʼєкти: 

* Альфа тестувальник (**alpha tester**);
* Бета тестувальник (**beta tester**).

### Альфа тестувальник (**alpha tester**)

Це співробітники компанії, які професійно чи непрофесійно проводять тестування: тестувальники, розробники, бухгалтери, сисадміни, девопси. У стартапах напередодні релізу нерідко всі працівники, сидять по 16 годин поспіль, намагаючись знайти не відловлені баги.

### Бета тестувальник (**beta tester**)

Не співробітник компанії, котрому пощастило першим побачити нову версію ПЗ. Це можуть бути як і найняті юзери для закритого тестування, так і просто частина вже наявних юзерів (зазвичай 1-10%) 

## За позитивністю сценаріїв

- Позитивне тестування (**positive testing**). Перевірка позитивних сценаріїв користувача. На вхід подаються очікувані дані.

- Негативне тестування (**negative testing**). Перевіряє реакцію системи на введення негативних (не дозволених/некоректних) даних.

## **За ступенем автоматизації**

Тому перед тим як буде перевірена нова функціональність потрібно перевірити чи працює вся інша. 

Є три види. Ручне, Автоматизоване і Напівавтоматизоване тестування 

### Ручне тестування (manual testing)

Ручне тестування (**manual testing**). Тестувальник не використовує інструменти автоматизації. 

Ручне тестування найгнучкіше, воно дозволяє  швидко тестувати систему в глибину, та закриває потребу в перевірці модулів тут і зараз.

### Автоматизоване тестування (automated testing).

Автоматизоване тестування (**automated testing**). Тестування всіх рівнях виконується з допомогою засобів автоматизації.  

Цей спосіб допомагає перевіряти великі системи швидше, відносно мануального тестування. З мінусів цього виду є те, що автотести важко підтримувати та при будь-якій зміні модуля, треба переписувати більшість тестів пов'язаних з ним. 

### Напівавтоматизоване тестування (**semiautomated testing**). 

Напівавтоматизоване тестування (**semiautomated testing**). Передбачається, що з певних цілей застосовується автоматизація. 

Напівавтоматизоване тестування бере найкраще з мануального та автотестів. Завдяки йому можна мануально перевірити якісь речі, що зараз в розробці та будуть часто змінюватись. І автоматизувати ті речі, що вже мають якісь фінальні форми.  Тим самим ми не витрачаємо наш фокус уваги на якісь рутинні перевірки приділяючи максимальну увагу новим змінам.

## За часом проведення тестування

1. Альфа-тестування. Імітація реальної роботи внутрішньою командою. Також під час тестування використовують тестування повʼязане зі змінами, а саме: 
    1. Димове тестування (**smoke testing**)
    2. Ре-тест **(Re-test)**
    3. Санітарне тестування (**sanity testing**) 
    4. Регресійне тестування (**regression testing**)
2. Приймальне тестування (**acceptance testing**)
3. Бета-тестування

Якщо розглядати за таймлайном, то ми спочатку робимо Альфа-тестування під час розробки, потім Приймальне тестування за завершенням розробки та потім Бета-тестування за межами команди.   

Тестування  повʼязані зі змінами хоч і згадуються в тестуванні за часом, але це є окремий вид тестування. Тому більш детально про тестування повʼязані зі змінами, нижче буде розписано окремим пунктом.    

## Тестування за змінами
Тому перед тим як буде перевірена нова функціональність потрібно перевірити чи працює вся інша. 



|                | Димове (Smoke)                                                                                 | Ре-тест (Re-test)                                     | Саніті (Sanity)                                                                                     | Регресійне (Regression)                                                                                                                                              |
| -------------- | ---------------------------------------------------------------------------------------------- | ----------------------------------------------------- | --------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Мета           | Виконуються з метою швидкої перевірки критично важливої функціональності                       | Мета - перевірити є чи були виправлені дефекти        | Метою є перевірити загальний стан системи в деталях, щоб приступити до більш ретельного тестування. | Мета — переконатися, що свіжі зміни в коді не надали побічних ефектів на функціональність, що була розроблена і протестована раніше.                                 |
| Пріоритет      | Пріоритет виконання найвищий                                                                   | Ре-тест виконується перед sanity-тестуванням.         | Виконується перед регресивним тестуванням                                                           | Проводиться на підставі вимог проєкт та доступності ресурсів (закривається автотестами), «регрес» може проводитись у паралелі з ре-тестами                           |
| Автоматизація | Може виконуватись автоматизовано або вручну                                                    | Не піддається автоматизації                           | Найчастіше виконується вручну                                                                       | Найкращий привід для автоматизації цього виду тестування тому, що  ручне може бути вкрай витратним за ресурсами чи часом                                             |
| Документація   | Тест-кейси є частиною регресійних тест-кейсів, але покривають вкрай критичну функціональність. | Використовується той же тест-кейс, який виявив дефект | Санітарне може виконуватися без тест-кейсів, але знання системи, що тестується, обов'язково         | Тест-кейси регресійного тестування можуть бути отримані з функціональних вимог або специфікацій, мануалів, і проводяться незалежно від того, що виправили розробники |



### Оффтоп

На співбесідах часто ставлять питання “В чому відмінність санітарного тестування від димового (Sanity vs Smoke testing)?”

У деяких джерелах помилково вважають, що санітарне та димове тестування – це одне й теж. Ми ж вважаємо, що ці види тестування мають "вектори руху", напрямки в різні боки. На відміну від димового (Smoke testing), санітарне тестування (Sanity testing) спрямоване вглиб функції, що перевіряється, тоді як димове направлено вшир, для покриття тестами якомога більшого функціонала в найкоротші терміни.

**<mark style="background: #FFB8EBA6;">Наприклад</mark>:** Ви хочете купити кавун. Димове тестування - це коли ви перевіряєте його візуально, дивіться на смужки, стискаєте, стукаєте, оцінюєте. Є майстри, які примудряються так купити справді смачну ягоду. У санітарному тестуванні ви вирізуєте пірамідку у верхній частині та перевіряєте її колір (як один із компонентів), при цьому зовсім не знаєте, чи такий кавун весь. Але за вирізану частину ви цілком впевнені.

## **За рівнями тестування**

![](https://lh5.googleusercontent.com/FKwEQByTUaLo3q40rni7ZYEVTFmM6MB1aZlUdiHVSQeQyBmX3dPEyQOwI4_lIYyxgJTifQQEpTzH1b9gmOXXzO5hcaU0FLp0XFK9hRc0zlwqRllGS_KqVhZPZUTxuhZF4Oecp_sip5SYYED2Box4rgM)

### ​​Модульне тестування (Unit testing) 

Тестується мінімально можливий для тестування компонент, <mark style="background: #FFB8EBA6;">Наприклад</mark>, окремий клас або функція, невеликі бібліотеки, окремі частини програми. Як правило, їх можна досліджувати ізольовано один від одного. Зазвичай модульне тестування здійснюється розробниками програмного забезпечення.

### Інтеграційне тестування (Integration testing) 

Тестуються інтерфейси між компонентами, підсистемами чи системами. Направлено на перевірку взаємодії між декількома частинами програми (кожну з яких перевірено на модульній стадії тестування). За наявності резерву часу цієї стадії тестування ведеться ітераційно, з поступовим підключенням наступних підсистем.

### Системне тестування (**System testing**)

Тестується інтегрована система її відповідність вимогам. Направлено на перевірку всієї програми, як єдиного цілого, зібраного з частин, перевірених на модульному та інтеграційному рівнях.

### Приймальне тестування (**Acceptance Testing**)

Це формальний процес тестування, який перевіряє відповідність системи вимогам і проводиться з метою визначення, чи задовольняє система приймальним критеріям та винесення рішення замовником або іншою уповноваженою особою приймається додаток чи ні.

## За об'єктом тестування

### Функціональне і нефункціональне тестування. Як відрізняти ?

Перед тим як розмовляти більш детально, найбільша різниця між ними це те що функціональне тестування полягає у тестуванні функціональностей наявних у додатку та переконання у тому, що вони працюють згідно зі специфікаціями. Нефункціональне тестування стосується аспектів програмного забезпечення, які не пов’язані з конкретними функціями чи операціями. Це оцінює роботу системи з точки зору відповідності набору вимог, таких як продуктивність, безпека, сумісність та стабільність.

1. Функціональне тестування (**functional testing**). Перевірка функцій та характеристик ПЗ, що розробляється на основі проєктної документації;
	
	<mark style="background: #FFB8EBA6;">Наприклад</mark>
	
	В нас є додаток для купівлі квитків на потяг. Функціональне тестування полягає в тому, щоб перевірити чи працює функціональність яка була у вимогах, а саме: купівлі, повернення квитків, вибору місця та оплати за них тощо.
	
	Після того ми можемо чітко сказати, яка функціональність працює згідно зі специфікаціями, а яку варто переробити.

2. Тестування продуктивності (**performance testing**). Перевіряє працездатність системи під навантаженням. Може служити для перевірки та підтвердження інших атрибутів якості системи, таких як масштабованість, надійність та споживання ресурсів. Виділяються такі підвиди:
	* Навантажувальне тестування (**load testing**). Тестування часу відповіді програми на запити різних типів, з метою переконатися, що додаток працює відповідно до вимог при звичайному користувацькому навантаженні.
	* Стрес-тестування (**stress testing**). При стрес-тестуванні (найчастіше, тільки при ньому) ми можемо отримати реальні дані границь продуктивності додатка, досліджувати здатність програми обробляти виключення, її стабільність та стійкість. Саме в значно збільшених навантаженнях на додаток і полягає різниця між тестуванням продуктивності та стрес тестуванням.
	* Тестування стабільності (**stability testing**). Досліджує працездатність додатка при тривалій роботі у часі за нормального навантаження програми.

3. Юзабіліті-тестування (**usability testing**). Мета даного виду тестування полягає у визначенні ступеня зручності та практичності користувальницького інтерфейсу;
	
	<mark style="background: #FFB8EBA6;">Наприклад</mark>
	
	Є додаток для купівлі продуктів в супермаркеті. І нам як тестувальнику потрібно перевірити, чи зручно використовувати наш сервіс звичайному користувачу.
	
	Щоб йому зручно було знайти потрібний товар, вибрати його, та купити.
	
	Якщо ж щось знаходиться не в зручному місці це може призвести до збитків замовника.

4. Тестування графічного інтерфейсу користувача (**GUI**) — це метод тестування, в якому перевіряється відповідність графічного інтерфейсу користувача заданим стандартам та вимогам які становив замовник.

	<mark style="background: #FFB8EBA6;">Наприклад</mark>
	
	Є той самий додаток для купівлі продуктів. Але тепер ми повинні перевірити чи відповідає розроблений сайт специфікаціям які надав замовник та дизайну який розробили дизайнери.
	
	Це важливо, тому що нестача якогось елемента може призвести не тільки до візуально поганого вигляду, а й проблем у головних механіках та функціональностях.

5. Тестування безпеки (**Security Testing**). Перевірка надійності системи від можливих ризиків та загроз (втрата, конфіденційність, цілісність та доступність даних). Варто зазначити що таке тестування проводиться спеціалістами цієї сфери;

6. Тестування локалізації (**localization testing**). Коректність роботи окремих компонентів системи (формати дат, одиниці виміру, не змінюється часовий пояс під час переїзду тощо);
	
	<mark style="background: #FFB8EBA6;">Наприклад</mark>
	
	В нас є міжнародний сайт з навчальними статтями. Під час цього тестування ми повинні перевірити чи всі статті переведені на підтримувані мови, переведені всі формати дат, одиниць виміру, часовий пояс та багато чого іншого.
	
	Це важливо, тому що через це, бізнес може втратити багато користувачів з різних регіонів і це справжнє неподобство.

7. Тестування інтернаціоналізації (**internationalization**). Дозволяє переконатися у підтримці культурних особливостей інших країн (головним чином у мовній підтримці).
	
	<mark style="background: #FFB8EBA6;">Наприклад</mark>
	
	В нас є так само міжнародний сайт. Але зараз ми тестуємо сайт на інтернаціоналізацію. Тобто якщо в нас цільова аудиторія з арабських та європейських країн ми повинні враховувати, що при перекладі написи будуть не з права наліво, а з ліву на право.
	
	Це так само як і минулий приклад при відсутності тесту бізнес може втратити багато користувачів.

8. Тестування сумісності (**compatibility testing**). Перевірка можливості програми взаємодіяти з різними програмними продуктами, операційними системами та оточенням.